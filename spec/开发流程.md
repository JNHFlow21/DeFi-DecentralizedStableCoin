好，下面按你从 0 到 1 实现这个重构后稳定币引擎的顺序拆成模块/里程碑，给每个要先写的功能：要做什么、为什么要做、这个功能的目的/作用、怎么写（实现思路和要点）。最后给你一份完整的 NatSpec 接口文档（函数、参数、返回值、事件、错误），你可以拿去直接写合约注释和做对照测试。

⸻

一、从 0 到 1 的开发分解（按依赖顺序）

1. 开发环境与基本依赖准备（先做）
	•	要做什么：确定开发环境（Foundry 或 Forge 项目结构）、引入 OpenZeppelin、Chainlink 依赖、写好合约框架文件、设定编译器版本 pragma solidity 0.8.19，准备 stablecoin 合约接口（DecentralizedStableCoin）的 minimal ABI/接口。
	•	为什么要做：没有干净、确定的环境你后续每一步都会被编译/依赖错误拖慢。把依赖和接口先明确，后面各模块可以独立写、测试。
	•	目的：打基础，确保编译、导入、交互接口（mint/burn/transferFrom）正常。
	•	怎么写：
	•	初始化项目（如果用 Foundry：forge init），设置 .env 变量（如果需要地址/price feed 等配置）。
	•	安装依赖：OpenZeppelin contracts、Chainlink（price feed interface）、你自己的 stablecoin 合约的路径。
	•	编写 interface / minimal stub：DecentralizedStableCoin 要暴露 mint(address,uint256) returns(bool), burn(uint256), transferFrom(address,address,uint256) returns(bool) 等（按现有实现约定）。
	•	写好通用常量、权限控制基础（ReentrancyGuard 继承、modifier skeleton）。

2. 价格预言机包装与适配（Oracle 处理）
	•	要做什么：封装 Chainlink price feed 的调用逻辑，包括过期检查、动态 decimals 处理，暴露拿某个 token 数量对应 USD 值和反向（USD 债务需要多少 token）的方法。
	•	为什么要做：所有抵押估值、清算、健康因子核心计算都依赖于价格。必须保证价格精准、不会用过期或错误的小数假设。
	•	目的：统一、健壮、可扩展的价格获取与单位归一层。
	•	怎么写：
	•	用 AggregatorV3Interface 读取最新一轮数据，并通过你的 OracleLib（或自己写的封装）做 stale check（判断 timestamp 不能太老）。
	•	拿到 price 和 price feed 的 decimals()，做标准化：比如 price * amount * PRECISION / (10 ** feedDecimals) 得到 USD 价值（内部统一用 1e18 精度）。
	•	反向逻辑：给定一个 USD 数（也按 PRECISION 缩放），算需要多少 token：(usd * (10**feedDecimals)) / price / PRECISION。
	•	封装成 internal view 函数 _getUsdValue 和 getTokenAmountFromUsd，确保外部可复用。

3. 抵押管理（deposit / redeem）
	•	要做什么：实现用户存入 ERC20 抵押物与赎回逻辑（不涉及 mint/burn），包括状态更新、ERC20 transfer、事件、合法性校验（token 被允许、amount>0）。
	•	为什么要做：抵押是系统的资产来源，必须先有抵押才能做铸币和清算。
	•	目的：安全、可追踪地记录每个用户每个 token 的抵押，以及能把抵押退给人。
	•	怎么写：
	•	depositCollateral: 检查 token 被允许、amount > 0。更新 s_collateralDeposited[user][token]，transferFrom 该 token 进合约，emit 事件。
	•	redeemCollateral: 检查 amount、token、更新抵押记录，把 token transfer 给用户，emit 事件。
	•	注意 underflow/overflow（Solidity 0.8 自带保护），但要写清楚先更新内部状态再做外部调用以防 reentrancy/回退风险。

4. 债务系统：铸造和还债（mint / burn）
	•	要做什么：实现用户在抵押充足时铸造 DSC（增加债务）和用 DSC 还债（减少债务）。
	•	为什么要做：稳定币发行核心：只有在外部价值足够时才允许铸造，铸造之后形成债务（系统负债），需要能让用户还债恢复安全状态。
	•	目的：保持 overcollateralization，用户通过债务与抵押比例受控。
	•	怎么写：
	•	_mintDsc: 增加 s_DSCMinted[user]，调用 stablecoin 合约 mint（检查返回值），再检查健康因子没有被破坏。emit DscMinted。
	•	_burnDsc: 减少目标用户 debt，调用 transferFrom 从提供 DSC 的地址拿回并 burn，在内部更新债务映射。emit DscBurned。
	•	外部 wrapper mintDsc/burnDsc 只允许自己对自己操作。清算时会用内部版本对别人做 onBehalfOf。

5. 健康因子与风险控制（Health Factor 计算与检查）
	•	要做什么：实现 health factor 的公式（抵押按阈值调整后的价值 / 债务）以及失败判定逻辑（低于 min 需 revert）。
	•	为什么要做：这是系统安全的 guardrail，防止用户过度铸币、抵押被取走导致系统变坏。清算依据也基于它。
	•	目的：量化抵押 vs 债务的安全性，用一个数字驱动逻辑分支。
	•	怎么写：
	•	_calculateHealthFactor(totalDscMinted, collateralValueInUsd) 返回一个以 PRECISION 缩放的 health factor。
	•	_revertIfHealthFactorIsBroken(user) 比较是否低于 MIN_HEALTH_FACTOR（即 <1），不安全则 revert 自定义 error 包含当前值。
	•	在所有改变债务/抵押的外部路径后调用：mint、redeem、burn、liquidate 的适当位置调用该检查（清算者也要保护自己）。

6. 组合/便捷操作（deposit + mint, redeem + burn）
	•	要做什么：实现复合操作接口：一次抵押并铸币；一次赎回并还债。
	•	为什么要做：用户体验层面：减少多次交易 gas 与原子性（要么全做要么全不做）。
	•	目的：封装常见使用路径，减少调用复杂度。
	•	怎么写：
	•	external 函数 depositCollateralAndMintDsc 和 redeemCollateralForDsc，分别组合上述模块内部函数。
	•	统一加 nonReentrant，内部调用的是没有 guard 的 _depositCollateral、_mintDsc、_burnDsc 等避免嵌套冲突。

7. 清算逻辑（liquidate）
	•	要做什么：实现当某用户 health factor < 1 时，清算者用自己 DSC 去覆盖用户债务并获得其抵押 + bonus。
	•	为什么要做：系统自我修复机制：奖励“救火人”保持整体 collateralization，清除不安全头寸。
	•	目的：把处于欠抵押的账户恢复系统安全，同时激励别人做清算。
	•	怎么写：
	•	先判定目标用户 health factor 是否 < MIN（否则 reject）。
	•	计算需要拿走的抵押（getTokenAmountFromUsd）+ 额外 bonus。
	•	从 target user 取走抵押并给 liquidator（等价于 liquidator 获得折价的抵押）。
	•	调用 _burnDsc(debtToCover, user, liquidator)：用 liquidator 的 DSC 烧掉 user 的债务。
	•	后置校验：目标用户 health factor 必须改善；清算者自身 health factor 不能破坏（避免恶意清算造成对自己不安全）。
	•	emit LiquidationPerformed 事件包含关键信息。

8. 只读接口与工具函数（accessors）
	•	要做什么：实现一系列 view/pure 的 getter，供前端和测试：账户信息、健康因子、抵押总值、某 token 价格值、常量、已注册抵押 token 列表等。
	•	为什么要做：调试、前端显示、测试断言都依赖这些数据接口。
	•	目的：透明可查询、方便外部决策。
	•	怎么写：
	•	getAccountInformation, getHealthFactor, getCollateralBalanceOfUser, getAccountCollateralValue（要遍历支持抵押的 token）等。
	•	保证 pure/view 分类准确、无状态变更。

9. 权限与安全防护（modifier + nonReentrant + sanity）
	•	要做什么：写好 moreThanZero、isAllowedToken、nonReentrant 的使用边界和组合，确保没有逻辑路径绕开健康检查和 token 验证。
	•	为什么要做：防止 edge case 里被空操作、未授权 token、重入攻击破坏资产安全。
	•	目的：确保所有外部可变操作都经过合法性和安全性检查。
	•	怎么写：
	•	所有对状态变更的外部函数（mint/ burn / deposit / redeem / liquidate / 组合）加上合适 modifiers。
	•	internal helper 不带 guard，但只有外部 wrapper 公开。

10. 事件与可观测性（event 设计复核）
	•	要做什么：确认所有关键状态变化都有事件，包括新增的 DscMinted, DscBurned, LiquidationPerformed。
	•	为什么要做：链上索引、用户界面、后续审计/回溯。
	•	目的：可追踪、可监控。
	•	怎么写：在做对应状态变更后 emit，附带上下文（用户、数量、前后 health factor、清算细节）。

11. 边界情形与反脆弱（健壮性）
	•	要做什么：确定在债务为 0 时健康因子返回最大值；在 prices 失效时合约行为（依赖 OracleLib stale check）；清算不应该让清算者自身陷入风险。
	•	为什么要做：避免除零、异常价格导致系统僵死或不合理清算。
	•	目的：容错、异常安全。
	•	怎么写：在计算函数里处理零债务、使用 safe price fetch、清算后 health factor 改善检查。

12. 单元测试设计（虽然你说不要代码，但建议同时列出要测的）
	•	要做什么：写测试用例（后面你自己实现）覆盖：正常抵押+铸币+赎回、过度铸币导致健康因子下降被阻止、清算成功/失败、组合接口顺序、price feed 小数变化、事件触发、非允许 token 拒绝、0 数量拒绝等。
	•	为什么要做：确保每一块逻辑在实际链上行为如预期，没有 getchas。
	•	目的：稳定、可回归。
	•	怎么写：模块化 mock price feed，操纵价格制造欠抵押，验证清算 reward、验证 health factor 边界。

⸻

二、NatSpec 接口文档（拿去直接贴到合约顶部与每个函数）

合约级别说明

/**
 * @title DSCEngine
 * @notice 核心稳定币引擎。用户存入抵押品，铸造 DSC，并在欠抵押时被清算。系统保证 DSC 始终由超额抵押支持。
 * @dev 抵押品的估值依赖 Chainlink price feed，health factor 控制系统安全性。清算者用自己的 DSC 赎回欠抵押用户的债务并获取折价抵押品。
 */

Errors

/**
 * @notice 传入的 token 数组和对应 price feed 数组长度不一致
 */
error DSCEngine__TokenAddressesAndPriceFeedAddressesAmountsDontMatch();

/**
 * @notice 数值必须大于 0
 */
error DSCEngine__NeedsMoreThanZero();

/**
 * @notice 该 token 不是被允许的抵押品
 * @param token 传入的 token 地址
 */
error DSCEngine__TokenNotAllowed(address token);

/**
 * @notice ERC20 transfer 或 transferFrom 操作失败
 */
error DSCEngine__TransferFailed();

/**
 * @notice 操作导致用户的 health factor 低于最小阈值
 * @param healthFactorValue 当前 health factor（缩放后值）
 */
error DSCEngine__BreaksHealthFactor(uint256 healthFactorValue);

/**
 * @notice 铸造 DSC 失败（stablecoin 合约未成功 mint）
 */
error DSCEngine__MintFailed();

/**
 * @notice 目标用户 health factor 仍然正常（用于拒绝不必要的清算）
 */
error DSCEngine__HealthFactorOk();

/**
 * @notice 清算后用户的 health factor 没有变好（理论上不应该发生）
 */
error DSCEngine__HealthFactorNotImproved();

Events

/**
 * @notice 有用户存入某种抵押品
 * @param user 抵押者
 * @param token 抵押的 ERC20 token
 * @param amount 存入数量
 */
event CollateralDeposited(address indexed user, address indexed token, uint256 indexed amount);

/**
 * @notice 抵押被赎回（正常赎回或清算）
 * @param redeemFrom 原始抵押人
 * @param redeemTo 接收者（清算时可能不是原始人）
 * @param token 抵押 token
 * @param amount 数量
 */
event CollateralRedeemed(address indexed redeemFrom, address indexed redeemTo, address token, uint256 amount);

/**
 * @notice DSC 被铸造
 * @param user 受益人（负债增加人）
 * @param amountDscMinted 铸造数量
 * @param postHealthFactor 铸造后健康因子
 */
event DscMinted(address indexed user, uint256 amountDscMinted, uint256 postHealthFactor);

/**
 * @notice DSC 被烧掉（还债/清算）
 * @param onBehalfOf 谁的债务被减少
 * @param amountDscBurned 数量
 * @param postHealthFactor 还债后该账户的健康因子
 */
event DscBurned(address indexed onBehalfOf, uint256 amountDscBurned, uint256 postHealthFactor);

/**
 * @notice 清算执行
 * @param collateral 被取走的抵押 token
 * @param user 被清算用户
 * @param liquidator 清算者
 * @param debtCovered 覆盖的 DSC 债务
 * @param collateralTaken 原始抵押数量（不含 bonus）
 * @param bonusCollateral 清算奖励部分
 */
event LiquidationPerformed(
    address indexed collateral,
    address indexed user,
    address indexed liquidator,
    uint256 debtCovered,
    uint256 collateralTaken,
    uint256 bonusCollateral
);

核心函数 NatSpec（概要）

/**
 * @notice 抵押并铸造 DSC（原子操作）
 * @param tokenCollateralAddress 要抵押的 token 地址
 * @param amountCollateral 抵押数量
 * @param amountDscToMint 想铸造的 DSC 数量
 */
function depositCollateralAndMintDsc(address tokenCollateralAddress, uint256 amountCollateral, uint256 amountDscToMint) external;

/**
 * @notice 赎回抵押并还债
 * @param tokenCollateralAddress 赎回的抵押 token
 * @param amountCollateral 想拿回的抵押数量
 * @param amountDscToBurn 想烧掉（还掉）的 DSC 债务
 */
function redeemCollateralForDsc(address tokenCollateralAddress, uint256 amountCollateral, uint256 amountDscToBurn) external;

/**
 * @notice 只赎回抵押品（不会减少债务）
 * @param tokenCollateralAddress 抵押 token 地址
 * @param amountCollateral 赎回数量
 */
function redeemCollateral(address tokenCollateralAddress, uint256 amountCollateral) external;

/**
 * @notice 只还债（burn DSC）
 * @param amount 还掉的 DSC 数量
 */
function burnDsc(uint256 amount) external;

/**
 * @notice 清算不安全账户，用自己的 DSC 覆盖其债务并获取其抵押（含 bonus）
 * @param collateral 被用作抵押的 token
 * @param user 被清算的用户
 * @param debtToCover 想覆盖的 DSC 债务量
 */
function liquidate(address collateral, address user, uint256 debtToCover) external;

/**
 * @notice 只铸造 DSC（不做抵押）
 * @param amountDscToMint 铸造量
 */
function mintDsc(uint256 amountDscToMint) external;

/**
 * @notice 只抵押某个 token（不铸币）
 * @param tokenCollateralAddress 抵押 token 地址
 * @param amountCollateral 抵押数量
 */
function depositCollateral(address tokenCollateralAddress, uint256 amountCollateral) external;

/**
 * @notice 计算 health factor
 * @param totalDscMinted 账户已铸造的 DSC 债务
 * @param collateralValueInUsd 抵押总美元价值（按照 internal precision）
 * @return healthFactor 缩放后的健康因子（越大越安全）
 */
function calculateHealthFactor(uint256 totalDscMinted, uint256 collateralValueInUsd) external pure returns (uint256);

/**
 * @notice 查询账户的债务和抵押价值
 * @param user 目标用户
 * @return totalDscMinted 债务量
 * @return collateralValueInUsd 抵押的 USD 价值
 */
function getAccountInformation(address user) external view returns (uint256 totalDscMinted, uint256 collateralValueInUsd);

/**
 * @notice 按 token 数量获取其等值的 USD（内部统一 precision）
 * @param token 抵押 token
 * @param amount token 数量（按最小单位）
 */
function getUsdValue(address token, uint256 amount) external view returns (uint256);

/**
 * @notice 查询某个用户在某 token 上的抵押余额
 */
function getCollateralBalanceOfUser(address user, address token) external view returns (uint256);

/**
 * @notice 查询账户所有抵押的总美元价值（遍历支持的抵押 token）
 */
function getAccountCollateralValue(address user) external view returns (uint256 totalCollateralValueInUsd);

/**
 * @notice 给定美元债务，反推需要多少该 token 抵押（不含 bonus）
 * @param token 抵押 token
 * @param usdAmountInWei 美元债务（按 internal precision 扩展）
 */
function getTokenAmountFromUsd(address token, uint256 usdAmountInWei) external view returns (uint256);

/**
 * @notice 返回系统指标：precision / threshold / bonus 等
 */
function getPrecision() external pure returns (uint256);
function getLiquidationThreshold() external pure returns (uint256);
function getLiquidationBonus() external pure returns (uint256);
function getLiquidationPrecision() external pure returns (uint256);
function getMinHealthFactor() external pure returns (uint256);

/**
 * @notice 获取当前支持的所有抵押 token 列表
 */
function getCollateralTokens() external view returns (address[] memory);

/**
 * @notice 获取 DSC 合约地址
 */
function getDsc() external view returns (address);

/**
 * @notice 获取某个 token 的 price feed 地址
 */
function getCollateralTokenPriceFeed(address token) external view returns (address);

/**
 * @notice 获取某用户当前 health factor
 */
function getHealthFactor(address user) external view returns (uint256);


⸻

三、顺手做的开发/测试建议（不写代码但要做的检查点）
	1.	Mock 价格源：写一个可控的 Chainlink-like mock，用来在测试里调整 price 让 health factor 下降/上升。
	2.	健康因子临界测试：铸币前后、赎回前后、清算前后比对 health factor。
	3.	清算前提模拟：人为降价制造某用户 healthFactor < 1，验证清算者可以按预期拿到抵押 + bonus，并且被清算人债务下降。
	4.	组合接口正确性：depositCollateralAndMintDsc 在一个 tx 里要成功（注意 nonReentrant 设计），redeemCollateralForDsc 的顺序不能破坏健康因子。
	5.	拒绝路径：未允许的 token、0 数量、清算不应该触发、健康因子被破坏时 revert 的错误类型。
	6.	事件完整性：每个关键操作的 event 数据是否准确（包括清算细节、铸币后 health factor）。

⸻

四、优先级建议（第一轮迭代顺序做法）
	1.	环境 + interface stub（stablecoin, price feed）
	2.	价格获取模块（带 decimals + stale check）
	3.	抵押 deposit / redeem（基础资产流）
	4.	债务 mint / burn（核心债务系统）
	5.	健康因子计算与检查（所有修改点依赖它）
	6.	组合 API（一次性 deposit+mint / redeem+burn）
	7.	清算逻辑（最复杂、依赖前面都稳定）
	8.	只读 getters / accessors
	9.	事件、错误完善
	10.	写测试覆盖关键正/反路径

⸻

结束语

你可以按上面模块逐个做：每做完一项写对应的单元测试（先 mock 价格、假用户、铸币/赎回流程），确认行为与 NatSpec 定义一致。完成核心逻辑后做极端行情和清算测试。你想先从哪一块开始？